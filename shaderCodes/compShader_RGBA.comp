#version 430 core

// inputs from compute shader
//
// in uvec3 gl_NumWorkGroups;
// in uvec3 gl_WorkGroupID;
// in uvec3 gl_LocalInvocationID;
// in uvec3 gl_GlobalInvocationID;
// in uint gl_LocalInvocationIndex;
//
// more details at https://www.khronos.org/opengl/wiki/Compute_Shader#Inputs

// outputs will need to be either in a shader storage buffer object
// or an image load store
//
// more details at https://www.khronos.org/opengl/wiki/Compute_Shader#Outputs

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D out_tex;

void main() {
    // get position to read/write data from
    ivec2 pos = ivec2( gl_GlobalInvocationID.xy );
    ivec2 pos_ = pos;

    ivec2 dims = imageSize(out_tex);


    // countetr
    float count =  imageLoad( out_tex, pos ).a;
    //Value to be set
    int toSet = 0;
    if(count != 0.0)
    { 
        // float in_val = imageLoad( out_tex, pos ).r;
        // imageStore( out_tex, pos, vec4(in_val+1, 0.0, 0.0, 0.0 ) );
        // Read from r, save to g
        // get value stored in the image
        float in_val = imageLoad( out_tex, pos ).r;
        if(in_val == 1)
        {
            toSet = 1;
        }
        else//if(in_val == 0)
        {
            // Left
            if(pos.x - 1 >= 0)
            {
                pos_.x = pos.x - 1;
                if(imageLoad( out_tex, pos_ ).r == 1)
                    toSet = 1;
            }
            //Right
            if(pos.x + 1 < dims.x)
            {
                pos_.x = pos.x + 1;
                if(imageLoad( out_tex, pos_ ).r == 1)
                    toSet = 1;
            }
            pos_.x = pos.x;
            //Top
            if(pos.y - 1 >= 0)
            {
                pos_.y = pos.y - 1;
                //toSet = 9;
                if(imageLoad( out_tex, pos_ ).r == 1.0)
                    toSet = 1;
            }
            //Bottom
            if(pos.y + 1 < dims.y)
            {
                pos_.y = pos.y + 1;
                if(imageLoad( out_tex, pos_ ).r == 1)
                    toSet = 1;
            }
        }
        // store new value in image
        imageStore( out_tex, pos, vec4( imageLoad( out_tex, pos ).r, toSet, 0.0, 0.0 ) );

    }
    else
    {
        // float in_val = imageLoad( out_tex, pos ).r;
        // imageStore( out_tex, pos, vec4(in_val+2, 0.0, 0.0, 1.0) );
        //Read from g, save to r
        float in_val = imageLoad( out_tex, pos ).g;
        if(in_val == 1)
        {
            toSet = 1;
        }
        else//if(in_val == 0)
        {
            // Left
            if(pos.x - 1 >= 0)
            {
                pos_.x = pos.x - 1;
                if(imageLoad( out_tex, pos_ ).g == 1)
                    toSet = 1;
            }
            //Right
            if(pos.x + 1 < dims.x)
            {
                pos_.x = pos.x + 1;
                if(imageLoad( out_tex, pos_ ).g == 1)
                    toSet = 1;
            }
            pos_.x = pos.x;
            //Top
            if(pos.y - 1 >= 0)
            {
                pos_.y = pos.y - 1;
                if(imageLoad( out_tex, pos_ ).g == 1)
                    toSet = 1;
            }
            //Bottom
            if(pos.y + 1 < dims.y)
            {
                pos_.y = pos.y + 1;
                if(imageLoad( out_tex, pos_ ).g == 1)
                    toSet = 1;
            }
        }

        // store new value in image
        imageStore( out_tex, pos, vec4( toSet, imageLoad( out_tex, pos ).g, 0.0, 1.0 ) );
    }



    
}