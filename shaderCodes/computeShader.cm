#version 430 core

// inputs from compute shader
//
// in uvec3 gl_NumWorkGroups;
// in uvec3 gl_WorkGroupID;
// in uvec3 gl_LocalInvocationID;
// in uvec3 gl_GlobalInvocationID;
// in uint gl_LocalInvocationIndex;
//
// more details at https://www.khronos.org/opengl/wiki/Compute_Shader#Inputs

// outputs will need to be either in a shader storage buffer object
// or an image load store
//
// more details at https://www.khronos.org/opengl/wiki/Compute_Shader#Outputs

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(r32f, binding = 0) uniform image2D out_tex;

void main() {
    // get position to read/write data from
    ivec2 pos = ivec2( gl_GlobalInvocationID.xy );

    // get value stored in the image
    float in_val = imageLoad( out_tex, pos ).r;

    // store new value in image
    imageStore( out_tex, pos, vec4( in_val + 1, 0.0, 0.0, 0.0 ) );
}


    // // get value stored in the image
    // float in_one = imageLoad(mapOne, pos).r;
    // float in_two = imageLoad(mapTwo, pos).r;
    // float in_three = imageLoad(mapThree, pos).r;
    // if(counter == 0)
    // {
    //     //Read mapOne, Save mapTwo
    //     // imageStore(mapTwo,pos,vec4(in_one,0,0,0));
    //     if(in_one == 0)
    //     {
    //         ivec2 tempPos = pos;
    //         if((tempPos.x -1) >=0)
    //         {
    //             tempPos.x = tempPos.x - 1;
    //             float leftVal = imageLoad(mapOne, tempPos).r;
    //             if(leftVal == 1)
    //             {
    //                 imageStore(mapTwo,pos,vec4(1,0,0,0));
    //             }
    //             else
    //             {
    //                 imageStore(mapTwo,pos,vec4(0,0,0,0));
    //             }
    //         }
    //     }
    //     else// if(in_one == 1)
    //     {
    //         ivec2 tempPos = pos;
    //         if((tempPos.x + 1) < dims.x)
    //         {
    //             tempPos.x = tempPos.x + 1;
    //             if(imageLoad(mapOne, tempPos).r == 0)
    //             {
    //                 imageStore(mapTwo,pos,vec4(0,0,0,0));
    //             }
    //             else
    //             {
    //                 imageStore(mapTwo,pos,vec4(1,0,0,0));
    //             }
    //         }
    //     }
        

    //     counter = counter + 1;
    // }
    // else
    // {
    //     //Read mapTwo, Save mapOne
    //     // imageStore(mapOne,pos,vec4(in_two+1,0,0,0));
    //     if(in_two == 0)
    //     {
    //         ivec2 tempPos = pos;
    //         if(tempPos.x -1 >=0)
    //         {
    //             tempPos.x = tempPos.x - 1;
    //             if(imageLoad(mapTwo, tempPos).r == 1)
    //             {
    //                 imageStore(mapOne,pos,vec4(1,0,0,0));
    //             }
    //             else
    //             {
    //                 imageStore(mapOne,pos,vec4(0,0,0,0));
    //             }
    //         }
    //         else
    //         {
    //             imageStore(mapOne,pos,vec4(0,0,0,0));
    //         }
    //     }
    //     else// if(in_two == 1)
    //     {
    //         ivec2 tempPos = pos;
    //         if(tempPos.x +1 <dims.x)
    //         {
    //             tempPos.x = tempPos.x + 1;
    //             if(imageLoad(mapTwo, tempPos).r == 0)
    //             {
    //                 imageStore(mapOne,pos,vec4(0,0,0,0));
    //             }
    //             else
    //             {
    //                 imageStore(mapOne,pos,vec4(1,0,0,0));
    //             }
    //         }
    //     }

    //     counter = 0;
    // }
    
    

//}